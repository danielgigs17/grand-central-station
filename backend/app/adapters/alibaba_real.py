"""
Real Alibaba adapter implementation based on HAR file analysis.
This adapter uses the actual API endpoints discovered from manual testing.
"""
from typing import Dict, List, Optional, Any
from datetime import datetime
import httpx
import json
import re
from urllib.parse import urlencode, unquote
import asyncio

from app.adapters.base import PlatformAdapter, BrowserAdapter
from app.core.config import settings


class AlibabaRealAdapter(PlatformAdapter):
    """Real Alibaba messaging adapter based on reverse-engineered API."""
    
    # Base URLs discovered from HAR analysis
    LOGIN_BASE_URL = "https://login.alibaba.com"
    MESSAGE_BASE_URL = "https://message.alibaba.com"
    ONETALK_BASE_URL = "https://onetalk.alibaba.com"
    ACS_BASE_URL = "https://acs.h.alibaba.com"
    
    # Specific endpoints
    LOGIN_URL = f"{LOGIN_BASE_URL}/newlogin/login.do"
    CONVERSATION_LIST_URL = f"{ONETALK_BASE_URL}/message/listRecentConversationContactDetail.htm"
    
    # WebSocket endpoint for real-time messaging
    WS_URL = "wss://wss-imakamai.alibaba.com/"
    
    def __init__(self, account):
        super().__init__(account)
        self.csrf_token = None
        self.user_id = None
        self.ws_connection = None
        
        # Load session data if available
        if self.account.session_data:
            self.csrf_token = self.account.session_data.get("csrf_token")
            self.user_id = self.account.session_data.get("user_id")
            
    def _get_default_headers(self) -> Dict[str, str]:
        """Get Alibaba-specific headers based on HAR analysis."""
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36",
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Cache-Control": "max-age=0",
            "sec-ch-ua": '"Google Chrome";v="137", "Chromium";v="137", "Not/A)Brand";v="24"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"macOS"',
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-site",
        }
        
        if self.csrf_token:
            headers["X-CSRF-Token"] = self.csrf_token
            
        return headers
    
    async def authenticate(self) -> bool:
        """Authenticate with Alibaba using the real login flow."""
        try:
            # Step 1: Get login page
            login_page_url = f"{self.LOGIN_BASE_URL}/newlogin/icbuLogin.htm"
            params = {
                "origin": "message.alibaba.com",
                "flag": "1",
                "return_url": f"{self.MESSAGE_BASE_URL}/message/messenger.htm"
            }
            
            response = await self.client.get(login_page_url, params=params)
            if response.status_code != 200:
                self.logger.error(f"Failed to get login page: {response.status_code}")
                return False
            
            # Extract any necessary tokens from the login page
            # This would need to be implemented based on the actual HTML structure
            
            # Step 2: Perform login
            login_data = {
                "loginId": self.account.username,
                "password": self._encrypt_password(self.account.password),  # Password is encrypted
                "scene": "",
                "isIframe": "false",
                "banThirdCookie": "false",
                "isPasskey": "false",
                "buyerScene": "true",
                # These are anti-bot parameters that would need to be generated
                "bx-ua": "",  # Generated by JavaScript
                "bx-umidtoken": "",  # Generated by JavaScript
                "bx-sys": "ua-l:us__um-l:us__js:https://assets.alicdn.com/g/"
            }
            
            headers = self._get_default_headers()
            headers.update({
                "Content-Type": "application/x-www-form-urlencoded",
                "Origin": self.LOGIN_BASE_URL,
                "Referer": login_page_url + "?" + urlencode(params),
            })
            
            response = await self.client.post(
                self.LOGIN_URL,
                data=urlencode(login_data),
                headers=headers,
                follow_redirects=False
            )
            
            if response.status_code in [200, 302]:
                # Check if login was successful
                # Extract user ID and CSRF token from response or cookies
                self._extract_session_data(response)
                
                if self.user_id:
                    # Save session data
                    self.account.session_data = {
                        "csrf_token": self.csrf_token,
                        "user_id": self.user_id,
                        "cookies": dict(self.client.cookies),
                    }
                    self._save_cookies()
                    return True
                    
        except Exception as e:
            self.logger.error(f"Authentication failed: {e}")
            
        return False
    
    def _encrypt_password(self, password: str) -> str:
        """
        Encrypt password according to Alibaba's requirements.
        From HAR analysis, passwords are encrypted client-side.
        This is a placeholder - actual implementation would need the encryption algorithm.
        """
        # TODO: Implement actual password encryption based on JavaScript analysis
        self.logger.warning("Password encryption not implemented - using plain password")
        return password
    
    def _extract_session_data(self, response: httpx.Response):
        """Extract session data from login response."""
        # Extract CSRF token from response headers or body
        csrf_header = response.headers.get("x-csrf-token")
        if csrf_header:
            self.csrf_token = csrf_header
            
        # Extract user ID from cookies or response
        # This would need to be implemented based on actual response structure
        
    async def get_chats(self) -> List[Dict[str, Any]]:
        """Get list of conversations using the real API endpoint."""
        try:
            # From HAR analysis, this endpoint requires specific parameters
            params = {
                "contactEncryptAliIdList": [],  # List of encrypted contact IDs
                "contactEncryptAccountIdList": [],
                "chatTokens": ""  # Chat authentication tokens
            }
            
            # Extract CSRF token from page if needed
            if not self.csrf_token:
                await self._refresh_csrf_token()
            
            headers = self._get_default_headers()
            headers.update({
                "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
                "Origin": self.MESSAGE_BASE_URL,
                "Referer": f"{self.MESSAGE_BASE_URL}/",
            })
            
            data = {
                "params": json.dumps(params),
                "_csrf": self.csrf_token or ""
            }
            
            response = await self.client.post(
                self.CONVERSATION_LIST_URL,
                data=urlencode(data),
                headers=headers
            )
            
            if response.status_code == 200:
                result = response.json()
                # Parse the response to extract conversation data
                conversations = []
                
                # The actual response structure would need to be determined
                # This is a placeholder based on typical patterns
                if "data" in result:
                    for conv in result["data"]:
                        conversations.append({
                            "id": conv.get("conversationId"),
                            "title": conv.get("contactName", "Unknown"),
                            "last_message": conv.get("lastMessage", {}).get("content"),
                            "last_message_time": conv.get("lastMessage", {}).get("timestamp"),
                            "unread_count": conv.get("unreadCount", 0),
                            "platform_data": conv,
                        })
                        
                return conversations
                
        except Exception as e:
            self.logger.error(f"Failed to get chats: {e}")
            
        return []
    
    async def _refresh_csrf_token(self):
        """Refresh CSRF token from the message page."""
        try:
            response = await self.client.get(f"{self.MESSAGE_BASE_URL}/message/messenger.htm")
            if response.status_code == 200:
                # Extract CSRF token from HTML
                match = re.search(r'name="_csrf"\s+value="([^"]+)"', response.text)
                if match:
                    self.csrf_token = match.group(1)
                    
        except Exception as e:
            self.logger.error(f"Failed to refresh CSRF token: {e}")
    
    async def get_messages(self, chat_id: str, since: Optional[datetime] = None) -> List[Dict[str, Any]]:
        """Get messages for a conversation."""
        # TODO: Implement based on manual testing
        # Need to find the actual message retrieval endpoint
        self.logger.warning("get_messages not yet implemented - needs manual testing")
        return []
    
    async def send_message(self, chat_id: str, content: str, media: Optional[List[str]] = None) -> Dict[str, Any]:
        """Send a message."""
        # TODO: Implement based on manual testing
        # Need to find the actual message sending endpoint
        self.logger.warning("send_message not yet implemented - needs manual testing")
        return {}
    
    async def get_profile(self, user_id: str) -> Dict[str, Any]:
        """Get user profile."""
        # TODO: Implement based on manual testing
        self.logger.warning("get_profile not yet implemented - needs manual testing")
        return {}
    
    async def download_media(self, url: str, save_path: str) -> bool:
        """Download media file."""
        try:
            response = await self.client.get(url)
            if response.status_code == 200:
                with open(save_path, "wb") as f:
                    f.write(response.content)
                return True
        except Exception as e:
            self.logger.error(f"Failed to download media: {e}")
        return False


class AlibabaRealBrowserAdapter(BrowserAdapter):
    """Browser automation fallback for Alibaba messaging."""
    
    LOGIN_URL = "https://login.alibaba.com/newlogin/icbuLogin.htm"
    MESSAGE_URL = "https://message.alibaba.com/message/messenger.htm"
    
    async def authenticate(self) -> bool:
        """Authenticate using browser automation."""
        try:
            await self.init_browser()
            
            # Navigate to login page
            login_url = f"{self.LOGIN_URL}?origin=message.alibaba.com&flag=1&return_url={self.MESSAGE_URL}"
            await self.page.goto(login_url)
            
            # Wait for login form
            await self.page.wait_for_selector('input[name="loginId"]', timeout=10000)
            
            # Fill login form
            await self.page.fill('input[name="loginId"]', self.account.username)
            await self.page.fill('input[name="password"]', self.account.password)
            
            # Click login button
            await self.page.click('button[type="submit"]')
            
            # Wait for navigation or error
            try:
                await self.page.wait_for_url("**/message/**", timeout=30000)
                # Login successful
                await self.save_browser_state()
                return True
            except:
                # Check for captcha or error message
                if await self.page.query_selector('.captcha-container'):
                    self.logger.error("CAPTCHA detected - manual intervention required")
                elif await self.page.query_selector('.error-message'):
                    error_text = await self.page.text_content('.error-message')
                    self.logger.error(f"Login error: {error_text}")
                else:
                    self.logger.error("Login failed - unknown error")
                    
        except Exception as e:
            self.logger.error(f"Browser authentication failed: {e}")
            
        return False
    
    async def get_chats(self) -> List[Dict[str, Any]]:
        """Get conversations using browser automation."""
        try:
            # Navigate to messages page if not already there
            if not self.page.url.startswith(self.MESSAGE_URL):
                await self.page.goto(self.MESSAGE_URL)
            
            # Wait for conversation list to load
            await self.page.wait_for_selector('.conversation-list', timeout=10000)
            
            # Extract conversation data
            conversations = await self.page.evaluate("""
                () => {
                    const convItems = document.querySelectorAll('.conversation-item');
                    return Array.from(convItems).map(item => ({
                        id: item.getAttribute('data-conversation-id'),
                        title: item.querySelector('.contact-name')?.textContent?.trim(),
                        lastMessage: item.querySelector('.last-message')?.textContent?.trim(),
                        unreadCount: parseInt(item.querySelector('.unread-count')?.textContent || '0')
                    }));
                }
            """)
            
            return conversations
            
        except Exception as e:
            self.logger.error(f"Failed to get chats via browser: {e}")
            
        return []
    
    async def send_message(self, chat_id: str, content: str, media: Optional[List[str]] = None) -> Dict[str, Any]:
        """Send message using browser automation."""
        try:
            # Click on the conversation
            await self.page.click(f'[data-conversation-id="{chat_id}"]')
            
            # Wait for message input
            await self.page.wait_for_selector('.message-input', timeout=5000)
            
            # Type message
            await self.page.fill('.message-input', content)
            
            # Send message (Enter key or send button)
            await self.page.press('.message-input', 'Enter')
            
            return {"success": True}
            
        except Exception as e:
            self.logger.error(f"Failed to send message via browser: {e}")
            
        return {"success": False}